package storage

import (
	"bytes"

	codec "github.com/kyegupov/parity-codec-go/noreflect"
)

// In Rust, StorageValue is a generic type, generated by decl_storage! macro.
// In Go, it's a runtime value describing the implementation.

// We cannot use codec.Decodeable, since some types are generic and need custom decoders from
// TypeParamsFactory
type StoredValue interface {
}

type SimpleStorageValue struct {
	KeyString  []byte // crateName + " " + typeName
	ConfigName string
	// TODO: build
	DefaultValueFactory func() StoredValue // For "Option<T>" types in Rust, this should return nil
	Decoder             func(pd codec.Decoder) StoredValue
}

type OptionalStorageValue SimpleStorageValue // But has different methods

/// Load the value from the provided storage instance.
func (s *SimpleStorageValue) Get() StoredValue {
	hasValue, valueBytes := Get(s.KeyString)
	if hasValue {
		return s.Decoder(codec.Decoder{bytes.NewBuffer(valueBytes)})
	}
	return s.DefaultValueFactory()
}

/// Take a value from storage, removing it afterwards.
func (s *SimpleStorageValue) Take() StoredValue {
	hasValue, valueBytes := Get(s.KeyString)
	if hasValue {
		value := s.Decoder(codec.Decoder{bytes.NewBuffer(valueBytes)})
		Kill(s.KeyString)
		return value
	}
	return s.DefaultValueFactory()
}

func (s *SimpleStorageValue) Kill() {
	Kill(s.KeyString)
}

func (s *SimpleStorageValue) Put(val codec.Encodeable) {
	if val != nil {
		Put(s.KeyString, codec.ToBytes(val))
	}
}

/// Mutate the value under a key.
func (s *SimpleStorageValue) Mutate(transformation func(StoredValue) codec.Encodeable) codec.Encodeable {
	val := transformation(s.Get())
	if val != nil {
		Put(s.KeyString, codec.ToBytes(val))
	}
	return val
}

type MapStorageValue struct {
	PrefixString []byte // crateName + " " + typeName
	ConfigName   string
	// TODO: build
	DefaultValueFactory func() StoredValue // For "Option<T>" types in Rust, this should return nil
	Decoder             func(pd codec.Decoder) StoredValue
}

/// Get the storage key used to fetch a value corresponding to a specific key.
func (s *MapStorageValue) keyFor(key codec.Encodeable) []byte {
	var buffer = bytes.NewBuffer(s.PrefixString)
	key.ParityEncode(codec.Encoder{buffer})
	return buffer.Bytes()
}

/// Load the value from the provided storage instance.
func (s *MapStorageValue) Get(key codec.Encodeable) StoredValue {
	hasValue, valueBytes := Get(s.keyFor(key))
	if hasValue {
		return s.Decoder(codec.Decoder{bytes.NewBuffer(valueBytes)})
	}
	return s.DefaultValueFactory()
}

/// Take a value from storage, removing it afterwards.
func (s *MapStorageValue) Take(key codec.Encodeable) StoredValue {
	hasValue, valueBytes := Get(s.keyFor(key))
	if hasValue {
		value := s.Decoder(codec.Decoder{bytes.NewBuffer(valueBytes)})
		Kill(s.keyFor(key))
		return value
	}
	return s.DefaultValueFactory()
}

func (s *MapStorageValue) Insert(key codec.Encodeable, val codec.Encodeable) {
	if val != nil {
		Put(s.keyFor(key), codec.ToBytes(val))
	}
}

/// Mutate the value under a key.
func (s *MapStorageValue) Mutate(key codec.Encodeable, transformation func(StoredValue) codec.Encodeable) codec.Encodeable {
	val := transformation(s.Get(key))
	if val != nil {
		Put(s.keyFor(key), codec.ToBytes(val))
	}
	return val
}
